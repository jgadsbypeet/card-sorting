// Card Sorting Application Database Schema
// This schema supports both open and closed card sorting studies

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// Authentication Models (NextAuth.js)
// ============================================================================

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  password      String?   // For credentials auth
  role          UserRole  @default(ADMIN)
  
  accounts      Account[]
  sessions      Session[]
  studies       Study[]   @relation("StudyOwner")
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

enum UserRole {
  ADMIN
  RESEARCHER
  VIEWER
}

// ============================================================================
// Study Models
// ============================================================================

model Study {
  id          String      @id @default(cuid())
  name        String
  description String?     @db.Text
  slug        String      @unique // For shareable URLs
  mode        SortingMode @default(OPEN)
  status      StudyStatus @default(DRAFT)
  
  // Settings
  allowUndo            Boolean @default(true)
  showProgress         Boolean @default(true)
  requireAllCardsSorted Boolean @default(false)
  randomizeCards       Boolean @default(true)
  timeLimitMinutes     Int?    // null = no limit
  instructions         String? @db.Text
  thankYouMessage      String? @db.Text
  
  // Relationships
  ownerId    String
  owner      User              @relation("StudyOwner", fields: [ownerId], references: [id])
  cards      Card[]
  categories PredefinedCategory[]
  sessions   ParticipantSession[]
  
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  
  @@index([ownerId])
  @@index([slug])
  @@index([status])
}

enum SortingMode {
  OPEN   // Participants create their own categories
  CLOSED // Pre-defined categories
}

enum StudyStatus {
  DRAFT     // Not yet published
  ACTIVE    // Accepting responses
  PAUSED    // Temporarily stopped
  COMPLETED // Finished collecting
  ARCHIVED  // Hidden from active list
}

// ============================================================================
// Card Models
// ============================================================================

model Card {
  id          String  @id @default(cuid())
  label       String
  description String? @db.Text
  sortOrder   Int     @default(0) // For consistent ordering
  
  studyId     String
  study       Study   @relation(fields: [studyId], references: [id], onDelete: Cascade)
  
  placements  CardPlacement[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([studyId])
}

// Pre-defined categories for closed sorting
model PredefinedCategory {
  id        String @id @default(cuid())
  name      String
  sortOrder Int    @default(0)
  
  studyId   String
  study     Study  @relation(fields: [studyId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  
  @@index([studyId])
}

// ============================================================================
// Participant Session Models
// ============================================================================

model ParticipantSession {
  id          String         @id @default(cuid())
  displayId   String         // Anonymous identifier like "P001"
  status      SessionStatus  @default(IN_PROGRESS)
  
  // Timing
  startedAt   DateTime       @default(now())
  completedAt DateTime?
  durationMs  Int?           // Total time in milliseconds
  
  // Metadata (anonymous)
  userAgent       String?
  screenWidth     Int?
  screenHeight    Int?
  accessibilityMode AccessibilityMode?
  
  // Stats
  totalMoves   Int @default(0)
  undoCount    Int @default(0)
  
  // Relationships
  studyId           String
  study             Study                @relation(fields: [studyId], references: [id], onDelete: Cascade)
  createdCategories CreatedCategory[]    // For open sorting
  placements        CardPlacement[]
  actionLog         SessionAction[]
  
  @@index([studyId])
  @@index([status])
  @@index([startedAt])
}

enum SessionStatus {
  IN_PROGRESS
  COMPLETED
  ABANDONED
}

enum AccessibilityMode {
  MOUSE
  KEYBOARD
  SCREEN_READER
  TOUCH
}

// Categories created by participants (open sorting)
model CreatedCategory {
  id        String @id @default(cuid())
  name      String
  sortOrder Int    @default(0)
  
  sessionId String
  session   ParticipantSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  
  placements CardPlacement[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([sessionId])
}

// Where each card was placed
model CardPlacement {
  id       String @id @default(cuid())
  position Int    // Position within the category
  
  cardId    String
  card      Card   @relation(fields: [cardId], references: [id], onDelete: Cascade)
  
  sessionId String
  session   ParticipantSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  
  // For open sorting - links to created category
  createdCategoryId String?
  createdCategory   CreatedCategory? @relation(fields: [createdCategoryId], references: [id], onDelete: SetNull)
  
  // For closed sorting - stores the predefined category name
  // (We store name instead of ID for easier analysis when categories might change)
  categoryName String
  
  placedAt DateTime @default(now())
  
  @@unique([sessionId, cardId]) // Each card placed once per session
  @@index([sessionId])
  @@index([cardId])
}

// Action log for replay and detailed analysis
model SessionAction {
  id        String     @id @default(cuid())
  type      ActionType
  details   Json       // Flexible storage for action-specific data
  timestamp DateTime   @default(now())
  
  sessionId String
  session   ParticipantSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  
  @@index([sessionId])
  @@index([timestamp])
}

enum ActionType {
  MOVE_CARD
  CREATE_CATEGORY
  RENAME_CATEGORY
  DELETE_CATEGORY
  UNDO
  START_SESSION
  COMPLETE_SESSION
}
